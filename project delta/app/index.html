<!--

  The entire application is just 1 html file right now.
  I have tried to comment my code sufficiently
  but i want this to actually make progress and not end up
  being some perfect piece of code that literally does
  nothing, so it may look messy
  Use a synax higlighter if you want to stay sane.

  this is a long term project and i don't periodically
  clean up old code, so some stuff may actually be useless
  It's bad practice, but i would rather it work.
 -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Template</title>
    <!-- Load ALL THE THINGS! -->
    <script>window.nodeRequire = require; delete window.require; delete window.exports; delete window.module;</script>
    <script src="jquery/dist/jquery.min.js" type="text/javascript"></script>
    <link rel="stylesheet" href="bootstrap-3.3.7-dist/css/bootstrap.css"></script>
    <script src="bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="mathquill-0.10.1/mathquill.css"></script>
    <script src="mathquill-0.10.1/mathquill.min.js"></script>
    <link rel="stylesheet" type="text/css" href="core_styles.css">

    <!-- done with the Loading of ALL THE THINGS! -->
  </head>
  <body class ="bamboo">
    <div class="hat" id="hat">
      <div align="center" id="large_menu" class="btn-group-vertical col-sm-3 hidden-xs" style="padding:10px">
          <button type="button" onclick="new_page()" class="btn btn-primary btn-block btn-default">New Page</button>
          <button type="button" onclick="help()" class="btn btn-primary btn-block btn-default">Help</button>
      </div>
      <div align="center" class="col-sm-6 col-xs-12">
        <h1 id="title-box" class="editable" align="center">Title</h1>
      </div>
      <div align="center" class="btn-group-vertical col-sm-3 col-xs-6" style="padding:10px">
        <button type="button" onclick="openFile()" class="btn btn-primary btn-block btn-default">Open</button>
        <button type="button" onclick="saveFile(()=>{});" class="btn btn-primary btn-block btn-default">Save As</button>
      </div>
      <div align="center" id="small_menu" class="btn-group-vertical hidden-sm hidden-lg hidden-md col-xs-6" style="padding:10px">
        <button type="button" onclick="new_page()" class="btn btn-primary btn-block btn-default">New Page</button>
        <button type="button" onclick="help()" class="btn btn-primary btn-block btn-default">Help</button>
      </div>
    </div>
    </div>
    <div class="background"></div>
    <div class="top-spacer"></div>
    <div id="sheets"></div>
    <script>
      var override_event = false;
      var change_div_size =(dom,change_up)=>{//there are different div sizes and this function allows for easy expansion
        var sizes = [
          "single-line",
          "double-line",
          "triple-line",
        ]
        var oldsize = 0;
        for (var i = 0; i < sizes.length; i++) {
          if(dom.hasClass(sizes[i])){
            oldsize=i;
          }
        }
        if(change_up){
          dom.removeClass(sizes[oldsize]).addClass(sizes[oldsize+1])
        } else {
          dom.removeClass(sizes[oldsize]).addClass(sizes[oldsize-1])
        }
      }
      var mathquillify =(selector)=> {//mathqill is a library that makes typing math easy. mathquillify converts a line of text into a mathquill field.
        selector.removeClass("monospace")
        var mathFieldSpan = selector[0]
        var MQ = MathQuill.getInterface(2); // for backcompat
        var mathField = MQ.MathField(mathFieldSpan, {
          spaceBehavesLikeTab: true, // configurable
          handlers: {
            moveOutOf:function(){
              override_event=true;
              if(arguments[0]==-1){
                if (current_line_number !== false ) { //this means that a line is selected. this sould work under all circumstances
                  if(current_line_number==0){//first line
                    //TBD
                  } else {//anything else
                    var newline =current_page.lines[current_line_number-1];
                    if(newline.isMQ){
                      newline.MQ.focus();
                    } else {
                      newline.span.focus();
                      setCaretPosition(newline.span[0],newline.span.text().length)
                    }
                  }
                }
              } else {//ok, we are moving forward
                if(current_line_number==current_page.lines.length-1){//last line
                  //tbd
                } else {
                  var newline =current_page.lines[current_line_number+1];
                  if(newline.isMQ){
                    newline.MQ.focus();
                  } else {
                    newline.span.focus();
                  }
                }
              }
            },
            deleteOutOf:function () {
              override_event=true;
              if (current_line_number !== false ) { //this means that a line is selected
                var line = current_page.lines[current_line_number]
                if(line.MQ.latex()==""){//stops accidentla deletion
                  if(current_line_number==0){
                    //if it's the first line, don't delete!
                  } else {
                    var preceding_line = current_page.lines[current_line_number-1];
                    current_page.lines.splice(current_line_number,1)
                    line.MQ.revert()
                    line.dom.remove()
                    line.span.remove()
                    if (preceding_line.isMQ) {
                      preceding_line.MQ.focus()
                    } else {
                      preceding_line.span.focus()
                      setCaretPosition(preceding_line.span[0],preceding_line.span.text().length)//sets the cursor in the right spot
                    }
                  }
                }
              }
            },
            upOutOf:function () {
              console.log("Leaving MQ");override_event=true;
              if (current_line_number !== false ) { //this means that a line is selected. this sould work under all circumstances
                if(current_line_number==0){//first line
                  //TBD
                } else {//anything else
                  var newline =current_page.lines[current_line_number-1];
                  if(newline.isMQ){
                    newline.MQ.focus();
                  } else {
                    newline.span.focus();
                  }
                }
              }
            },
            downOutOf:function () {
              override_event=true;
              if(current_line_number==current_page.lines.length-1){//last line
                //tbd
              } else {
                var newline =current_page.lines[current_line_number+1];
                if(newline.isMQ){
                  newline.MQ.focus();
                } else {
                  newline.span.focus();
                }
              }
            },
            edit: function() { // useful event handlers
              var div_container = selector.parent()
              var mathquill_block = selector.find(".mq-root-block")
              var adjust_font=()=>{
                if(selector.find(".mq-root-block").height()<div_container.height()){
                  for (var i = 0; i < 25; i++) {
                    if(mathquill_block.height()<div_container.height()){
                      var fontSize = parseInt(selector.css("font-size"));
                      fontSize = fontSize + 1 + "px";
                      selector.css({'font-size':fontSize});
                    }
                  }
                }
                if(mathquill_block.height()>div_container.height()){
                  for (var i = 0; i < 25; i++) {
                    if(mathquill_block.height()>div_container.height()){
                      var fontSize = parseInt(selector.css("font-size"));
                      fontSize = fontSize - 1 + "px";
                      selector.css({'font-size':fontSize});
                    }
                  }
                }
              }
              fitDiv =(i)=>{
                if (i > 3) return false; //stops infinite loop
                var fontSize = parseInt(selector.css("font-size"));
                if (fontSize < 18) {
                  change_div_size(div_container,true);//auto-grow
                  adjust_font();
                  fitDiv(i+1);
                } else if (fontSize > 35){
                  change_div_size(div_container,false);//auto shrink
                  adjust_font();
                  fitDiv(i+1);
                }
              }
              adjust_font();
              fitDiv()
            }
          }
        });
        return mathField
      }
      var getCaretPosition =(element)=> {//gets the cursor position
        var caretOffset = 0;
        var doc = element.ownerDocument || element.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (typeof win.getSelection != "undefined") {
          sel = win.getSelection();
          if (sel.rangeCount > 0) {
            var range = win.getSelection().getRangeAt(0);
            var preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
          }
        } else if ( (sel = doc.selection) && sel.type != "Control") {
          var textRange = sel.createRange();
          var preCaretTextRange = doc.body.createTextRange();
          preCaretTextRange.moveToElementText(element);
          preCaretTextRange.setEndPoint("EndToEnd", textRange);
          caretOffset = preCaretTextRange.text.length;
        }
        return caretOffset;
      }
      var setCaretPosition =(el, pos)=> { //sets the cursor position
        for(var node of el.childNodes){
          if(node.nodeType == 3){ // we have a text node
            if(node.length >= pos){
              // finally add our range
              var range = document.createRange(),
              sel = window.getSelection();
              range.setStart(node,pos);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
              return -1; // we are done
            }else{
              pos -= node.length;
            }
          }else{
            pos = setCaretPosition(node,pos);
            if(pos == -1){
              return -1; // no need to finish the for loop
            }
          }
        }
        return pos; // needed because of recursion stuff
      }
      ((/*Keybindings*/)=>{
        $("body").on("keydown",function(e){
          if(override_event){//useful for MQ
            override_event=false;
            e.preventDefault();
            return;
          }
          if(e.keyCode==37){//left
            if (current_line_number !== false ) { //this means that a line is selected
              var oldline =current_page.lines[current_line_number]
              if(oldline.isMQ){//mq is diferent
              } else { //is cursor @ beginning of line
                if(getCaretPosition(oldline.span[0])==0){//are we at beginning of text?
                  if(current_line_number!=0){//we move to previous line only if there is one
                    var preceding_line = current_page.lines[current_line_number-1];
                    if (preceding_line.isMQ) {
                      preceding_line.MQ.focus()
                    } else {
                      preceding_line.span.focus()
                      setCaretPosition(preceding_line.span[0],preceding_line.span.text().length)//sets the cursor in the right spot
                      e.preventDefault()
                    }
                  }
                }
              }
            }
          }
          if(e.keyCode==46){//delete
            if (current_line_number !== false ) { //this means that a line is selected
              var line = current_page.lines[current_line_number]
              if(line.isMQ){
                //mq is handled within the mathquill library
              } else { //is cursor @ beginning?
                if(getCaretPosition(line.span[0])==line.span.text().length){//are we at end of text?
                  if(current_line_number!=current_page.lines.length-1){//cant delete end of line
                    var next_line = current_page.lines[current_line_number+1];
                    if (next_line.isMQ) {
                      //TBD
                    } else {
                      current_page.lines.splice(current_line_number+1,1);//now remove old line
                      var next_line_text = next_line.span.text()
                      var self_text = line.span.text()
                      line.span.text(self_text+"@"+next_line_text);//add this lines text to the last line. the extra char is because we don't want to override the deleting action
                      next_line.span.remove();//delete it from doc
                      next_line.dom.remove();
                      setCaretPosition(line.span[0],self_text.length)
                    }
                  }
                }
              }
            }
          }
          if(e.keyCode==38){//up
            if (current_line_number !== false ) { //this means that a line is selected
              var oldline =current_page.lines[current_line_number]
              if(oldline.isMQ){
                //mq is diferent, only switch if the cursor doesn't move
              } else { //is cursor @ beginning of line
                if(current_line_number!=0){//we move to previous line only if there is one
                  var preceding_line = current_page.lines[current_line_number-1];
                  if (preceding_line.isMQ) {
                    preceding_line.MQ.focus()
                  } else {
                    var cursorpos = getCaretPosition(oldline.span[0])
                    var maxpos=current_page.lines[current_line_number-1].span.text().length
                    if(maxpos<cursorpos){
                      cursorpos=maxpos
                    }
                    setCaretPosition(preceding_line.span[0],cursorpos)//sets the cursor in the right spot
                    preceding_line.span.focus()
                    e.preventDefault()
                  }
                }
              }
            }
          }
          if(e.keyCode==39){//right
            console.log("foo");
            if (current_line_number !== false ) { //this means that a line is selected
              var oldline =current_page.lines[current_line_number]
              if(oldline.isMQ){//mq is diferent
              } else { //is cursor @ beginning of line
                if(getCaretPosition(oldline.span[0])==oldline.span.text().length){//are we at end of text?
                  if(current_line_number!=current_page.lines.length-1){//we move to previous line only if there is one
                    var next_line = current_page.lines[current_line_number+1];
                    if (next_line.isMQ) {
                      next_line.MQ.focus()
                    } else {
                      next_line.span.focus()
                      setCaretPosition(next_line.span[0],0)//sets the cursor in the right spot
                      e.preventDefault()
                    }
                  }
                }
              }
            }
          }
          if(e.keyCode==40){//down
            if (current_line_number !== false ) { //this means that a line is selected
              var line = current_page.lines[current_line_number];
              if (current_page.lines[current_line_number].isMQ) {
                //let MQ lib handle this instead for more accuracy w fractions
              } else {
                if(current_line_number==current_page.lines.length-1){
                  //don't override
                } else {
                  e.preventDefault()
                  var next_line=current_page.lines[current_line_number+1];
                  if(next_line.isMQ){
                    next_line.MQ.focus()
                  } else {
                    var cursorpos = getCaretPosition(line.span[0])
                    var maxpos=next_line.span.text().length
                    if(maxpos<cursorpos){
                      cursorpos=maxpos
                    }
                    setCaretPosition(current_page.lines[current_line_number+1].span[0],cursorpos)
                  }
                }
              }
            }
          }
          if(e.keyCode==8) {//backspace
            if (current_line_number !== false ) { //this means that a line is selected
              var line = current_page.lines[current_line_number]
              if(line.isMQ){
                //mq is handled within the mathquill library
              } else { //is cursor @ beginning?
                if(getCaretPosition(line.span[0])==0){//are we at beginning of text?
                  if(current_line_number!=0){//don't want to delete whole page
                    var preceding_line = current_page.lines[current_line_number-1];
                    if (preceding_line.isMQ) {
                      //so what we need to do is focus it
                      preceding_line.MQ.focus()
                    } else {
                      var text = line.span.text();
                      var preceding_line_text = preceding_line.span.text()
                      var new_cursor_pos = preceding_line_text.length+1;
                      preceding_line.span.text(preceding_line_text+"@"+text);//add this lines text to the last line. the extra char is because we don't want to override the deleting action
                      current_page.lines.splice(current_line_number,1);//now remove old line
                      line.span.remove();//delete it from doc
                      line.dom.remove();
                      preceding_line.span.focus()
                      setCaretPosition(preceding_line.span[0],new_cursor_pos)//sets the cursor in the right spot
                    }
                  }
                }
              }
            }
          }
        })
        $("body").on('keypress', function (e) {//we use two differetnt types of binding because keypress is generally better but we cant overide backspace with it
          if(e.which === 13 && !e.ctrlKey /*enter*/ ){
            event.preventDefault()
            console.log("ENTER PRESSED:\n\n\nline:"+current_line_number)
            if (current_line_number !== false ) { //this means that a line is selected
              if(current_page.lines[current_line_number].isMQ){
                //what does happen if the current line is mq? probably we shoulld just focus on the next line like desmos does
                if(current_page.lines.length-1==current_line_number){//is this the last line? if so, lets add another
                  current_page.addline("normal");
                  current_page.lines[current_page.lines.length-1].span.focus()
                } else {//ok, lets just focus the next line
                  if (typeof current_page.lines[current_line_number+1].MQ != undefined) {//mq objects are special.
                    current_page.lines[current_line_number+1].span.focus()
                  } else {
                    current_page.lines[current_line_number+1].MQ.focus()
                  }
                }
              } else {
                var orig_line = current_page.lines[current_line_number];
                var orig_line_num = current_line_number
                var position = getCaretPosition(orig_line.span[0]);
                var left_text= orig_line.span.text().substring(0,position);
                var right_text= orig_line.span.text().substring(position);
                var next_line=current_page.injectline("",orig_line_num)
                console.log("position:"+position+"\nleft: \""+left_text+"\",\nright:\""+right_text+"\"")
                orig_line.span.blur()
                next_line.span.text(right_text).focus();
                orig_line.span.empty().text(left_text);
              }
            }
            //$(this).attr("disabled", "disabled");



          }
          if (e.which == 12){//ctrl + l means mathquillify or demathquillify. this is so long because we have to keep the array ordered
            console.log("M");
            if (current_line_number !== false ) {
              var line = current_page.lines[current_line_number];
              if (line.isMQ) {
                var hold_line_number = current_line_number //this value gets modified during some operations
                line.MQ.revert()
                var text = line.span.text();
                var newline=current_page.injectline("normal",current_line_number)//inject a line after current one
                current_page.lines.splice(hold_line_number,1)//remove that old line from the list
                line.span.remove()//and from the document
                line.dom.remove()
                newline.span.text(text);//give it correct text
                newline.span.focus()//focus it
              } else {
                console.log("Q");
                line.format.clear();
                // line.dom.addClass("double-line").removeClass("single-line")
                var text = line.span.text();
                line.span.text("").attr("contentEditable",false);
                line.MQ = mathquillify(line.span);
                // setTimeout(()=>{line.MQ.focus()},0)
                line.MQ.destroy=line.MQ.revert
                line.MQ.revert=()=>{
                  var latex = line.MQ.latex()
                  line.MQ.destroy();
                  line.span.removeClass("mq-focused").addClass("monospace")
                  line.span.text(latex)
                  make_editable(line.span);
                  line.span.focus();
                }
                text=text.replace("+-","\\pm")//convienence things
                text=text.replace("\\sqrt","sqrt")
                text=text.replace("sqrt","\\sqrt")
                text=text.replace("\\pi","pi")
                text=text.replace("pi","\\pi")
                for (var i = 0; i < text.length; i++) {
                  if(text[i]==" "){
                    line.MQ.keystroke("Spacebar");
                  } else {
                    line.MQ.typedText(text[i]);
                  }
                }
                line.isMQ=true;//this allows for easy distinction between text and math lines
                var this_page=current_page
                line.span.set_active = function() {
                  current_line_number=line.getNumber()
                  console.log("focus: "+line.getNumber())
                  current_page=this_page;
                }
                line.span.set_inactive = function() {
                  self_line_number=line.getNumber()
                  console.log(self_line_number)
                  if(current_line_number==self_line_number){
                    console.log("de focus: "+current_line_number)
                    current_line_number=false;
                  };
                }
                line.bind=function(){
                  line.span.find(".mq-textarea").find("textarea").bind('focus',line.span.set_active);
                  line.span.find(".mq-textarea").find("textarea").bind('blur',line.span.set_inactive);
                };line.bind()

                line.MQ.focus();
              }
            }
          }
          if(e.which==14){//ctrl + n creates a new page
            new_page();
          }
          if (e.which==11) {//ctrl and k changes size from 2 to 1 or from 1 to 2
            console.log("Size");
            if (current_line_number !== false ) {
              console.log("go!");
              var line = current_page.lines[current_line_number];
              line.dom.toggleClass("double-line").toggleClass("single-line")
            }
          }
        });
      })();
      var current_line_number=false//this global variable is either false if no line is selected or a number if one is
      var current_page=false//same here
      var pages = []; //global var
      var make_editable =(dom)=>{//this just helps jquery know when somehting is clicked by autofocusing it.
        dom.bind('click', function() {
          $(this).focus()
        })
        dom.attr("contentEditable",true)
      }
      function Formatting(){
        dom = arguments[0]
        this.dom        = dom;
        this.bold       = {
          status:false,
          dom:dom,
          change:function () {
            if (!this.status) {
              this.dom.css("font-weight","Bold")
              this.status=true;
            } else {
              this.dom.css("font-weight","")
              this.status=false;
            }
          }
        }
        this.italics    = {
          status:false,
          dom:dom,
          change:function () {
            if (!this.status) {
              this.dom.css("font-style","italic")
              this.status=true;
            } else {
              this.dom.css("font-style","")
              this.status=false;
            }
          }
        }
        this.underline  = {
          status:false,
          change:null,
          dom:null,
        }
        this.highlight  = {
          status:0,
          dom:dom.find("span"),
          names:[
            "none",
            "red",
            "orange",
            "yellow",
            "green",
            "cyan",
            "blue",
          ],
          values:[
            "#FFFFFF",
            "#FF0000",
            "#FF8000",
            "#FFFF00",
            "#00FF00",
            "#00FFFF",
            "#0000FF",
          ],
          change:function(value){
            if(typeof value == "string"){
              value = this.names.indexOf(value);
            }
            this.dom.css("background-color",this.values[value])
          }
        }
        this.clear=()=>{
          this.bold.status = true;
          this.bold.change();//sets it to the opposite, then changes it
          this.highlight.change(0)
          this.italics.status = true;
          this.italics.change();
          this.underline.status = true;
          this.underline.change();
        }
        this.dump=()=>({
          bold:this.bold.status,
          highlight:this.highlight.status,
          underline:this.underline.status,
          italics:this.italics.status
        })
        if(arguments.length>1){
          if (typeof arguments[1]==undefined) {

          }
          params=arguments[1];
          this.bold.status = !params.bold;
          this.bold.change();//sets it to the opposite, then changes it
          this.highlight.change(params.highlight)
          this.italics.status = !params.italics;
          this.italics.change();
          // this.underline.status = !params.underline;
          // this.underline.change();
        }
      }
      function InjectLineAfter(line_x_dom){//this is actually an object constructer. its complicated-- sometimes we need to add a line after a line and other times we don't have any line to add it to.
        var tempid = Math.floor(Math.random()*Math.pow(2,16))//ok yes techincally you could have this run simletaneously and get two similar random numberss and have all hell break loose, but this is sufficent
        line_x_dom.after('<div align="left" class="id'+tempid+' single-line"></div>')
        this.dom = $(".id"+tempid);
        this.dom.removeClass("id"+tempid)
        this.dom.append("<span class='monospace editable id"+tempid+"'></span>")
        this.span=$(".id"+tempid);
        this.span.removeClass("id"+tempid)
        this.format=new Formatting(this.dom);
        this.isMQ=false;
        make_editable(this.span)
      }
      function Line(dom){//todo: separate span and div
        var tempid = Math.floor(Math.random()*Math.pow(2,16))
        dom.append('<div align="left" class="id'+tempid+' single-line"></div>')
        this.dom = $(".id"+tempid);
        this.dom.removeClass("id"+tempid)
        this.dom.append("<span class='monospace editable id"+tempid+"'></span>")
        this.span=$(".id"+tempid);
        this.span.removeClass("id"+tempid)
        this.isMQ=false;
        this.format=new Formatting(this.dom);
        make_editable(this.span)
      }
      function Page(){
        var tempid = Math.floor(Math.random()*Math.pow(2,16))
        $("#sheets").append('<div class="id'+tempid+' outerpaper" align="center"><div class="innerpaper" align="left">')
        this.dom=$(".id"+tempid)
        this.dom.removeClass("id"+tempid)
        this.lines=[];
        this.injectline=(type,original_line_number)=>{
          console.log(original_line_number);
          var this_line = new InjectLineAfter(this.lines[original_line_number].dom);
          this.lines.splice(original_line_number+1, 0, this_line)
          if (this_line!=this.lines[original_line_number+1]) {
            throw "error in array splicing!"
          }
          var line_dom = this_line.span;
          this_line.getNumber=()=>(
            this_page.lines.indexOf(this_line)
          )
          var this_page= this;
          this_line.set_active = function() {
            current_line_number=this_line.getNumber()
            console.log("focus: "+this_line.getNumber())
            current_page=this_page;
          }
          this_line.set_inactive = function() {
            self_line_number=this_line.getNumber()
            console.log(self_line_number)
            if(current_line_number==self_line_number){
              console.log("de focus: "+current_line_number)
              current_line_number=false;
            };
          }
          this_line.bind=function(){
            this.span.bind('focus',this_line.set_active);
            this.span.bind('blur',this_line.set_inactive);
          };this_line.bind()
          return this_line
        }
        this.addline=(type)=>{
          this.lines.push(new Line(this.dom))
          var this_line=this.lines[this.lines.length-1]
          var line_dom = this_line.span;
          this_line.getNumber=()=>(
            this_page.lines.indexOf(this_line)
          )
          var this_page= this;
          this_line.set_active = function() {
            current_line_number=this_line.getNumber()
            console.log("focus: "+current_line_number)
            current_page=this_page;
          }
          this_line.set_inactive = function() {
            self_line_number=this_line.getNumber()
            console.log(self_line_number)
            if(current_line_number==self_line_number){
              console.log("de focus: "+current_line_number)
              current_line_number=false;
            };
          }
          this_line.bind=function(){
            this.span.bind('focus',this_line.set_active);
            this.span.bind('blur',this_line.set_inactive);
          };this_line.bind()
        }
        this.addline();
        this.lines[0].span.focus()
      }
      var new_page =()=>{
        pages.push(new Page())
      }
      var insert_line_on_page =(page_num)=>{//legacy function. use Page.addline or page.injectline
        var line_num = pages[page_num].internal_divs.length;
        pages[page_num].dom.append('<div align="left" id="pg'+page_num+'ln'+line_num+'" class="editable single-line"><span></span></div>')
        var line_dom = $('#pg'+page_num+'ln'+line_num)
        pages[page_num].internal_divs.push({dom:line_dom,internal_spans:[]})
        make_editable(line_dom)
      }
      make_editable($(".editable"))
      var save_to_json=()=>{
        var foo = {title_text:$("#title-box").text(),pages:[]}
        foo.focus={line:current_line_number,page:pages.indexOf(current_page)}
        for (var i = 0; i < pages.length; i++) {
          foo.pages[i]=[];
          for (var j = 0; j < pages[i].lines.length; j++) {
            if(pages[i].lines[j].isMQ){
              foo.pages[i][j]={
                isMQ:true,
                text:pages[i].lines[j].MQ.latex()
              }
            } else {
              foo.pages[i][j]={
                isMQ:false,
                text:pages[i].lines[j].span.text(),
                format:pages[i].lines[j].format.dump()
              }
            }
          }
        }
        return JSON.stringify(foo);
      }
      var help=()=>{
        alert("Just type things.\nPress ctrl + L to toggle math mode,\nPress ctrl + N for a new page.\nSave frequently, there isnt a safeguard in place right now.\nYou can rename the title if you click on it.\nThe cursor is tiny","Help")
      }
      var load_from_json=(instring)=>{
        pages=[];
        $("#sheets").empty()
        foo = JSON.parse(instring);
        $("#title-box").text(foo.title_text)
        for (var i = 0; i < foo.pages.length; i++) {
          new_page();
          current_page=pages[i]
          for (var j = 0; j < foo.pages[i].length; j++) {
            pages[i].addline();
            current_line_number=j;
            line=pages[i].lines[j];
            if(foo.pages[i][j].isMQ){//Broken rihgt now, and it kinda defeats the purpose of the whole program :/
              var mathquill_event = jQuery.Event("keypress");
              mathquill_event.which=12;
              $("body").trigger(mathquill_event)//we just convert the thing to mathquill using the preexising code
              line.MQ.latex(foo.pages[i][j].text)
            } else {
              line.span.text(foo.pages[i][j].text);
              line.format=new Formatting(line.dom,foo.pages[i][j].format);
            }
          }
        }
        var lineToFocus = pages[foo.focus.page].lines[foo.focus.line];
        if (lineToFocus.isMQ) {
          lineToFocus.MQ.focus()
        } else {
          lineToFocus.span.focus()
        }
      }
    </script>
    <script>
      require = window.nodeRequire
      var   remote          =  require('electron').remote;
      var   dialog          =  remote.dialog;
      var   fs              =  require('fs'); // require only if you don't already have it
      const ipc             =  require('electron').ipcRenderer
      var   sendMSG=(thing) => {ipc.send('sendMSG', thing)}

      ipc.on('string', (event, message) => {
        if (message=="save") {
          saveFile((success)=>{sendMSG("save_"+success)});
        }
      });
      ipc.on('recovery_data', (event, payload) => {
        load_from_json(payload);//if it crashes, recover data
        sendMSG("recovery_success")//stops the thing from oversending
        alert("Success!")
      });
      var autosave;
      setTimeout(()=>{
        auto2save = setInterval(()=>{
          ipc.send("backup_data",save_to_json())
        },20000)
      },10000)//this stops overwriting
      var ping = setInterval(()=>{
        ipc.send("ping",true)
      },3000)
      function saveFile (callback) {
        dialog.showSaveDialog({ filters: [
          { name: 'Notebook', extensions: ['jsonbook'] }
        ]},function (fileName) {
          if (fileName === undefined) return;
          fs.writeFile(fileName, save_to_json(), function (err) {
            if (err == undefined) {
              alert("The file has been saved")
              callback(true);
            } else {
              alert(err.message,"File Save Error");
              callback(false);
            }
          });
        });
      }
      function openFile () {
        dialog.showOpenDialog({ filters: [
          { name: 'Notebook', extensions: ['jsonbook'] }
        ]},function (fileNames) {
          if (fileNames === undefined) return;
          var fileName = fileNames[0];
          fs.readFile(fileName, 'utf-8', function (err, data) {
            load_from_json(data)
          });
        });
      }
    </script>
  </body>
</html>
