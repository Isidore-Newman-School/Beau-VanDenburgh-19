<!--
  The entire application is just 1 html file right now.
  I have tried to comment my code sufficiently
  but i want this to actually make progress and not end up
  being some perfect piece of code that literally does
  nothing, so it may look messy
  Use a synax higlighter if you want to stay sane.

  this is a long term project and i don't periodically
  clean up old code, so some stuff may actually be useless
  It's a bad practice, but i would rather it work.
 -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Template</title>
    <script>
    const ipc = require('electron').ipcRenderer
    ipc.send("status","loading")
    window.nodeRequire = require;
    delete window.require;
    delete window.exports;
    delete window.module;
    </script>
    <script src="assets/jquery/dist/jquery.min.js" type="text/javascript"></script>
    <link rel="stylesheet" href="assets/bootstrap-4.0.0-alpha.6-dist/css/bootstrap.min.css"></script>
    <script src="assets/bootstrap-4.0.0-alpha.6-dist/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="assets/mathquill-0.10.1/mathquill.css"></script>
    <script src="assets/mathquill-0.10.1/mathquill.min.js"></script>
    <link rel="stylesheet" type="text/css" href="core_styles.css">
    <link rel="stylesheet" href="print.css">
    <!-- done with the Loading of ALL THE THINGS! -->
  </head>
  <body class ="bamboo">
    <div class="hat row" id="hat">
      <div align="center" id="large_menu" class="btn-group-vertical col-sm-3 hidden-xs-down" style="padding:10px">
        <button type="button" onclick="new_page()" class="btn btn-primary btn-block btn-default">New Page</button>
        <button type="button" onclick="help()" class="btn btn-primary btn-block btn-default">Help</button>
      </div>
      <div align="center" class="col-sm-6 col-xs-12">
        <h1 id="title-box" class="text-muted editable" align="center">Title</h1>
      </div>
      <div align="center" class="btn-group-vertical hidden-xs-down col-sm-3" style="padding:10px">
        <div class="btn-group" role="group">
          <button id="file-dropdown-lg" type="button" class="file-dropdown btn btn-primary btn-block btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            File
          </button>
          <div class="dropdown-menu" aria-labelledby="file-dropdown-lg">
            <a class="dropdown-item btn" onclick="save()">Save</a>
            <a class="dropdown-item btn" onclick="saveAs(()=>{})">Save As</a>
            <a class="dropdown-item btn" onclick="openFile()">Open</a>

          </div>
        </div>
        <button type="button" onclick="" class="btn btn-primary print-pdf btn-block btn-default">Print</button>
      </div>
      <div class="hidden-sm-up col-xs-4" style="width:50%">
        <div align="center" class="btn-group-vertical btn-block" style="padding:10px">
          <button id="file-dropdown-sm" type="button" class="file-dropdown btn btn-primary btn-block btn-default dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            File
          </button>
          <div class="dropdown-menu" aria-labelledby="file-dropdown-sm">
            <a class="dropdown-item btn" onclick="save()">Save</a>
            <a class="dropdown-item btn" onclick="saveAs(()=>{})">Save As</a>
            <a class="dropdown-item btn" onclick="openFile()">Open</a>
          </div>
          <button type="button" onclick="" class=" btn btn-primary btn-default">Print</button>
        </div>
      </div>
      <div class="hidden-sm-up col-xs-4" style="width:50%">
        <div align="center" class="btn-group-vertical btn-block" style="padding:10px">
          <button type="button" onclick="help()" class=" btn btn-primary btn-default">Help</button>
          <button type="button" onclick="new_page()" class=" btn btn-primary btn-default">New Page</button>
        </div>
      </div>
      <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Alert</h5>
              <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
            </div>
            <div class="modal-body">
              ...
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" onclick="modal_open=false" data-dismiss="modal">Close</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    </div>
    <div class="background"></div>
    <div class="top-spacer"></div>
    <div id="sheets"></div>
    <script>
      const debug_version = false;//used to suppress console.log
      var font_perf_data=[];//array of ints, used to collect data on how often we use jquery  to chekc fontsize
      var loading = false;
      var mathquillAutoFormatTimeoutId = {pid:0};
      var mqaftoid = mathquillAutoFormatTimeoutId;
      var global_override_mq_autofit = false;
      const sizes = [
        "single-line",
        "double-line",
        "triple-line",
        "quad-line",
        "five-line"
      ]
      /*
        basically, to stop mathquill from repeatedly trying to format, it will
        settimeout for the formatting operation, and will wait for the user
        to stop typing by canceling the pending operation whenever a new one is
        sceduled. think of it like waiting 5 minutes after you get an order
        of piza to make sure no other orders are coming in so you dont deliver
        each pizza individually

        the weird acronym is used becasue that variablename is long
      */
      var disable_keybinds = false;
      var get_div_size=(dom)=>{//returns an int representing the div size
        var oldsize = false;//if we cant find a size then return false
        for (var i = 0; i < sizes.length; i++) {
          if(dom.hasClass(sizes[i])){//we cant use indexOf because we're searching for a class
            oldsize=i;
          }
        }
        return oldsize;
      }
      var modal_open=false
      var show_info =(properties)=>{
        var info_box = $(".hat").append(`
          <div class="info new col-sm-12">
            <div class="alert fade alert-${properties.type} ${(()=>{if(properties.not_dismissable===false){return "alert-dismissible"}return ""})()}" role="alert">
              <button type="button" class="close" data-dismiss="alert" aria-label="Close">
                <span aria-hidden="true">&times;</span>
              </button>
              <strong>${properties.title}</strong><br>
              ${properties.message}
            </div>
          </div>
        `).find(".new").removeClass("new").find(".alert");
        setTimeout(()=>{info_box.addClass("show")},100)
        info_box.find("button").on("click",()=>{
          setTimeout(()=>{
            info_box.parent().remove()
          },3000)
        })
        return info_box
      }
      var modal_alert =(contents,title)=>{
        if(!modal_open){
          modal_open=true;
          var modal = $(".modal");
          modal.find(".modal-title").text(title);
          modal.find(".modal-body").html(contents);
          $(".modal").modal({backdrop:false});
        }
      }
      var auto_adjust_mathquill =(selector)=>{//this automatically fixes a mathquill object to make it take up as few lines as possible without having too small of a font
        var div_container = selector.parent()
        var mathquill_block = selector.find(".mq-root-block")
        var font_call_count = 0
        var get_font_size=function () {//returns font-size as an int
          font_call_count++;
          return parseInt(selector.css("font-size"));
        }
        var adjust_font_to_fit=()=>{//this just fixxes the font size so everything is within the parent div
          if(mathquill_block.height()<div_container.height()){
            var fontSize = get_font_size()
            while(mathquill_block.height()<div_container.height()){
              if(fontSize>50)break;
              fontSize+=1;
              selector.css('font-size',fontSize+"px");
            }
          } else {
            var fontSize = get_font_size()
            while(mathquill_block.height()>div_container.height()){
              fontSize-=1;
              if(fontSize<0)break;
              selector.css('font-size',fontSize+"px");
            }
            fontSize+=1;
            selector.css('font-size',fontSize+"px");
          }
        }
        var go_up=function () {//makes div larger and then fits font
          change_div_size(div_container,true);//auto-grow
          adjust_font_to_fit();
        }
        var go_down=function () {//opposite of go up. we have a debuglog here bec this is a frequent point of failure.
          if(debug_version){
            console.log("DN: new size:"+change_div_size(div_container,false));//auto-shrink
          } else {
            change_div_size(div_container,false)
          }
          adjust_font_to_fit();
        }
        adjust_font_to_fit();
        while (get_font_size() < 18) go_up();//never allow font size to go above 18
        go_up();
        while (get_font_size()*(1+(get_div_size(div_container)*0.05)) > 35) go_down();//we do the wierd multiplication because without it, it is impossible for an equasion to take up 4 lines, which is usefull for a double-fraction
        if(debug_version){
          console.log(`get_font_size was called ${font_call_count} times`)
          font_perf_data.push(font_call_count);
        }
      }
      var change_div_size =(dom,change_up)=>{//there are different div sizes and this function allows for easy expansion or shrinking
        oldsize=get_div_size(dom)
        if(change_up){
          if(oldsize==sizes.length-1){
            //welp
          } else {
            dom.removeClass(sizes[oldsize]).addClass(sizes[oldsize+1])
            return oldsize+1;
          }
        } else {
          if(oldsize==0){
            //welp
          } else {
            dom.removeClass(sizes[oldsize]).addClass(sizes[oldsize-1])
            return oldsize-1;
          }
        }
      }
      var mathquillify =(selector)=> {
        /*
          mathqill is a library that makes typing math easy. mathquillify
          converts a line of text into a mathquill field. before you critique me
          for using a wierd name, the authors of the library use this term.
        */
        selector.removeClass("monospace")//this fixes some font issues
        var mathFieldSpan = selector[0]//jquery -> plain old javascript
        var MQ = MathQuill.getInterface(2); // Devs of MQ say this is needed for backcompatibility. works fine like this.
        var mathField = MQ.MathField(mathFieldSpan, {
          spaceBehavesLikeTab: true, // configurable
          autoCommands: 'pi theta sqrt sum',//these are autoconverted to their symbols
          handlers: {
            moveOutOf:function(){//when we use the arrows to move out of this feild, these functions are called. they allow for page traversal
              disable_keybinds=true;
              if(arguments[0]==-1){
                if (current_line_number !== false ) { //this means that a line is selected. there is no situation where this should trigger, but its better to be safe then sorry
                  if(current_line_number==0){//first line
                    //If we are on the first line and try to move to the previous, what should happen? TBD.
                  } else {//anything else
                    var newline =current_page.lines[current_line_number-1];
                    if(newline.isMQ){
                      newline.MQ.focus();
                      newline.MQ.moveToRightEnd()
                    } else {
                      newline.span.focus();
                      setCaretPosition(newline.span[0],newline.span.text().length)
                    }
                  }
                }
              } else {//ok, we are moving forward
                if(current_line_number==current_page.lines.length-1){//last line
                  //tbd
                } else {
                  var newline =current_page.lines[current_line_number+1];
                  if(newline.isMQ){
                    newline.MQ.focus();
                  } else {
                    newline.span.focus();
                  }
                }
              }
            },
            deleteOutOf:function (direction) {//see moveoutof for explanation
              if (direction == 1) {//delete key
                if (current_line_number !== false ) { //this means that a line is selected
                  var line = current_page.lines[current_line_number]
                  if(line.MQ.latex()==""){//stops accidentla deletion
                    if(current_line_number==current_page.lines.length-1){
                      //if it's the last line, don't delete!
                    } else {
                      var next_line = current_page.lines[current_line_number+1];
                      current_page.lines.splice(current_line_number,1)
                      line.MQ.revert()
                      line.dom.remove()
                      line.span.remove()
                      if (next_line.isMQ) {
                        next_line.MQ.focus()
                        next_line.MQ.moveToLeftEnd()
                      } else {
                        next_line.span.focus()
                        setCaretPosition(next_line.span[0],0)//sets the cursor in the right spot
                      }
                    }
                  }
                }
              } else {//backspace key
                if (current_line_number !== false ) { //this means that a line is selected
                  var line = current_page.lines[current_line_number]
                  if(line.MQ.latex()==""){//stops accidentla deletion
                    if(current_line_number==0){
                      //if it's the first line, don't delete!
                    } else {
                      var preceding_line = current_page.lines[current_line_number-1];
                      current_page.lines.splice(current_line_number,1)
                      line.MQ.revert()
                      line.dom.remove()
                      line.span.remove()
                      if (preceding_line.isMQ) {
                        preceding_line.MQ.focus()
                        preceding_line.MQ.moveToRightEnd()
                      } else {
                        preceding_line.span.focus()
                        setCaretPosition(preceding_line.span[0],preceding_line.span.text().length)//sets the cursor in the right spot
                      }
                    }
                  }
                }
              }
              disable_keybinds=true;//this stops the next keypress in  the /*keybindings*/ function.
            },
            upOutOf:function () {
              if (debug_version) {
                console.log("Leaving MQ");
              }
              disable_keybinds=true;
              if (current_line_number !== false ) { //this means that a line is selected. this sould work under all circumstances
                if(current_line_number==0){//first line
                  //TBD
                } else {//anything else
                  var newline =current_page.lines[current_line_number-1];
                  if(newline.isMQ){
                    newline.MQ.focus();
                    newline.MQ.moveToRightEnd()
                  } else {
                    newline.span.focus();
                  }
                }
              }
            },
            downOutOf:function () {
              disable_keybinds=true;
              if(current_line_number==current_page.lines.length-1){//last line
                //tbd
              } else {
                var newline =current_page.lines[current_line_number+1];
                if(newline.isMQ){
                  newline.MQ.focus();
                  newline.MQ.moveToLeftEnd()
                } else {
                  newline.span.focus();
                }
              }
            },
            edit: function() { // when we edit it, we need to re-evaluate the size to make sure it isnt too small or large
              if(global_override_mq_autofit===true){return}
              clearTimeout(mathquillAutoFormatTimeoutId.pid)
              /*
                stops any pending operations. this saves on cpu cycles when
                typing things in really quicly and makes fractions look more
                animated bec they "snap in" instead of instantly appearing.
                if you dont like it, change the 50 to a 0
              */
              mathquillAutoFormatTimeoutId.pid=setTimeout(()=>{
                auto_adjust_mathquill(selector)
              },50)
            }
          }
        });
        return mathField
      }
      var getCaretPosition =(element)=> {//gets the cursor position. stolen from stackoverflow.
        var caretOffset = 0;
        var doc = element.ownerDocument || element.document;
        var win = doc.defaultView || doc.parentWindow;
        var sel;
        if (typeof win.getSelection != "undefined") {
          sel = win.getSelection();
          if (sel.rangeCount > 0) {
            var range = win.getSelection().getRangeAt(0);
            var preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            caretOffset = preCaretRange.toString().length;
          }
        } else if ( (sel = doc.selection) && sel.type != "Control") {
          var textRange = sel.createRange();
          var preCaretTextRange = doc.body.createTextRange();
          preCaretTextRange.moveToElementText(element);
          preCaretTextRange.setEndPoint("EndToEnd", textRange);
          caretOffset = preCaretTextRange.text.length;
        }
        return caretOffset;
      }
      var setCaretPosition =(el, pos)=> { //sets the cursor position. also stolen from stackoverflow.
        for(var node of el.childNodes){
          if(node.nodeType == 3){ // we have a text node
            if(node.length >= pos){
              // finally add our range
              var range = document.createRange(),
              sel = window.getSelection();
              range.setStart(node,pos);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
              return -1; // we are done
            }else{
              pos -= node.length;
            }
          }else{
            pos = setCaretPosition(node,pos);
            if(pos == -1){
              return -1; // no need to finish the for loop
            }
          }
        }
        return pos; // needed because of recursion stuff
      }
      var mathLineify=()=>{//used to toggle whether or not somethings a mathline
        console.log("M");//this means it was pressed. this is usefull for debugging.
        if (current_line_number !== false ) {
          var line = current_page.lines[current_line_number];
          if (line.isMQ) {
            var hold_line_number = current_line_number //this value gets modified during some operations
            line.MQ.revert()
            var text = line.span.text();
            var newline=current_page.injectline("normal",current_line_number)//inject a line after current one
            current_page.lines.splice(hold_line_number,1)//remove that old line from the list
            line.span.remove()//and from the document
            line.dom.remove()
            newline.span.text(text);//give it correct text
            newline.span.focus()//focus it
          } else {
            console.log("Q");//this is used to detect focus problems
            line.format.clear();
            // line.dom.addClass("double-line").removeClass("single-line")
            var text = line.span.text();
            line.span.text("").attr("contentEditable",false);
            line.MQ = mathquillify(line.span);
            // setTimeout(()=>{line.MQ.focus()},0)
            line.MQ.destroy=line.MQ.revert;
            line.MQ.revert=()=>{
              var latex = line.MQ.latex();
              line.MQ.destroy();
              line.span.removeClass("mq-focused").addClass("monospace");
              line.span.text(latex);
              make_editable(line.span);
              line.span.focus();
            }
            text=text.replace("+-","\\pm");//convienence things. this is where eventually things like fraction conversion will be handled
            text=text.replace("\\sqrt","sqrt");
            text=text.replace("sqrt","\\sqrt");
            text=text.replace("\\pi","pi");
            text=text.replace("pi","\\pi");
            for (var i = 0; i < text.length; i++) {
              if(text[i]==" "){
                line.MQ.keystroke("Spacebar");
              } else {
                line.MQ.typedText(text[i]);
              }
            }
            line.isMQ=true;//this allows for easy distinction between text and math lines
            var this_page=current_page;
            line.span.set_active = function() {
              current_line_number=line.getNumber();
              if (debug_version) {
                console.log("focus: "+line.getNumber());
              }
              current_page=this_page;
            }
            line.span.set_inactive = function() {
              self_line_number=line.getNumber();
              if(current_line_number==self_line_number){
                if (debug_version) {
                  console.log("de focus: "+current_line_number);
                }
                current_line_number=false;
              };
            }
            line.bind=function(){
              line.span.find(".mq-textarea").find("textarea").bind('focus',line.span.set_active);
              line.span.find(".mq-textarea").find("textarea").bind('blur',line.span.set_inactive);
            };
            line.bind();
            line.MQ.focus();
          }
        }
      }
      var breakLine=()=>{
        if (debug_version) {
          console.log("ENTER PRESSED:\n\n\nline:"+current_line_number)
        }
        if (current_line_number !== false ) { //this means that a line is selected
          if(current_page.lines[current_line_number].isMQ){
            //what does happen if the current line is mq? probably we shoulld just add another mq
            current_page.injectline('',current_line_number).span.focus();
            mathLineify()
          } else {
            var orig_line = current_page.lines[current_line_number];
            var orig_line_num = current_line_number
            var position = getCaretPosition(orig_line.span[0]);
            var left_text= orig_line.span.text().substring(0,position);
            var right_text= orig_line.span.text().substring(position);
            var next_line=current_page.injectline("",orig_line_num)
            orig_line.span.blur()
            next_line.span.text(right_text).focus();
            orig_line.span.empty().text(left_text);
          }
        }
      }
      ((/*Keybindings*/)=>{
        //To explain this anon function, there are two jquery functions
        //that occour on keypresses, so i use those for keybindings. a lot of
        //code (if statements) is copy pasted from other keys here because the
        //flowcharts for movement between boxes is somewhat similar between directions.
        $("body").on("keydown",function(e){
          if(loading===true){//this stops typing during loading
            e.preventDefault()
            return;
          }
          if(disable_keybinds===true){//useful for MQ
            disable_keybinds=false;
            e.preventDefault();
            return;
          }
          if(e.ctrlKey){
            text_formatted=true;
            if (debug_version) {
              console.log(`key ${e.keyCode} pressed`)
            }
            if(e.keyCode==66){//ctrl b
              e.preventDefault();//stops some text from bolding with chrome's built in editor
              if (current_line_number !== false ) { //this means that a line is selected
                if(!current_page.lines[current_line_number].isMQ){
                  current_page.lines[current_line_number].format.bold.change();
                }
              }
            } else if(e.keyCode==73){//ctrl + i
              e.preventDefault();
              if (current_line_number !== false ) { //this means that a line is selected
                if(!current_page.lines[current_line_number].isMQ){
                  current_page.lines[current_line_number].format.italics.change();
                }
              }
            } else {
              text_formatted=false;
              if (e.keyCode==83) {//save
                if(current_file_path==""){
                  saveAs(()=>{});
                } else {
                  save();
                }
              } else if (e.keyCode==80){//print
                $(".print-pdf").trigger("click")//admittedly this is lazy, but the electron print to pdf example is really confusing
              }
            }
            if(text_formatted){//if text is changed, we need to get rid of inline html tags (<b></b>)becasue they make formatting inconsistent.
              if(current_line_number!==false){
                line = current_page.lines[current_line_number];
                if (line.isMQ) {
                  //its ok
                } else {
                  if(line.span.children().length>0){
                    line.span.html(line.span.html().replace(/<\/?\w+((\s+\w+(\s*=\s*(?:".*?"|'.*?'|[\^'">\s]+))?)+\s*|\s*)\/?>/g,""))
                    //this matches any html tag and removes it. this is nessesary bec sometimes browsers format a part of a line. this was taken from stackoverflow.
                  }
                }
              }
            }
            if (e.keyCode==79){//ctrl + O
              openFile();
            }
          }
          if(e.keyCode==37){//left
            if (current_line_number !== false ) { //this means that a line is selected
              var oldline =current_page.lines[current_line_number]
              if(oldline.isMQ){//mq is diferent
              } else { //is cursor @ beginning of line
                if(getCaretPosition(oldline.span[0])==0){//are we at beginning of text?
                  if(current_line_number!=0){//we move to previous line only if there is one
                    var preceding_line = current_page.lines[current_line_number-1];
                    if (preceding_line.isMQ) {
                      preceding_line.MQ.focus()
                      preceding_line.moveToRightEnd()
                    } else {
                      preceding_line.span.focus()
                      setCaretPosition(preceding_line.span[0],preceding_line.span.text().length)//sets the cursor in the right spot
                      e.preventDefault()
                    }
                  }
                }
              }
            }
          }
          if(e.keyCode==46){//delete
            if (current_line_number !== false ) { //this means that a line is selected
              var line = current_page.lines[current_line_number]
              if(line.isMQ){
                //mq is handled within the mathquill library
              } else { //is cursor @ beginning?
                if(getCaretPosition(line.span[0])==line.span.text().length){//are we at end of text?
                  if(current_line_number!=current_page.lines.length-1){//cant delete end of line
                    var next_line = current_page.lines[current_line_number+1];
                    if (next_line.isMQ) {
                      if (line.span.text().length==0){
                        e.preventDefault();
                        current_page.lines.splice(current_line_number,1);//now remove this line
                        line.span.remove();
                        line.dom.remove();
                        next_line.MQ.focus();
                        next_line.MQ.moveToLeftEnd()
                      }
                    } else {
                      current_page.lines.splice(current_line_number+1,1);//now remove old line
                      var next_line_text = next_line.span.text()
                      var self_text = line.span.text()
                      e.preventDefault();
                      line.span.text(self_text+next_line_text);//add this lines text to the last line. the extra char is because we don't want to override the deleting action
                      next_line.span.remove();//delete it from doc
                      next_line.dom.remove();
                      setCaretPosition(line.span[0],self_text.length)
                    }
                  }
                }
              }
            }
          }
          if(e.keyCode==38){//up
            if (current_line_number !== false ) { //this means that a line is selected
              var oldline =current_page.lines[current_line_number]
              if(oldline.isMQ){
                //mq is diferent, only switch if the cursor doesn't move
              } else { //is cursor @ beginning of line
                if(current_line_number!=0){//we move to previous line only if there is one
                  var preceding_line = current_page.lines[current_line_number-1];
                  if (preceding_line.isMQ) {
                    preceding_line.MQ.focus()
                    preceding_line.MQ.moveToRightEnd
                  } else {
                    var cursorpos = getCaretPosition(oldline.span[0])
                    var maxpos=current_page.lines[current_line_number-1].span.text().length
                    if(maxpos<cursorpos){
                      cursorpos=maxpos
                    }
                    setCaretPosition(preceding_line.span[0],cursorpos)//sets the cursor in the right spot
                    preceding_line.span.focus()
                    e.preventDefault()
                  }
                }
              }
            }
          }
          if(e.keyCode==39){//right
            if (current_line_number !== false ) { //this means that a line is selected
              var oldline =current_page.lines[current_line_number]
              if(oldline.isMQ){//mq is diferent
              } else { //is cursor @ beginning of line
                if(getCaretPosition(oldline.span[0])==oldline.span.text().length){//are we at end of text?
                  if(current_line_number!=current_page.lines.length-1){//we move to previous line only if there is one
                    var next_line = current_page.lines[current_line_number+1];
                    if (next_line.isMQ) {
                      next_line.MQ.focus()
                      next_line.MQ.moveToLeftEnd()
                    } else {
                      next_line.span.focus()
                      setCaretPosition(next_line.span[0],0)//sets the cursor in the right spot
                      e.preventDefault()
                    }
                  }
                }
              }
            }
          }
          if(e.keyCode==40){//down
            if (current_line_number !== false ) { //this means that a line is selected
              var line = current_page.lines[current_line_number];
              if (current_page.lines[current_line_number].isMQ) {
                //let MQ lib handle this instead for more accuracy w fractions
              } else {
                if(current_line_number==current_page.lines.length-1){
                  //don't override
                } else {
                  e.preventDefault()
                  var next_line=current_page.lines[current_line_number+1];
                  if(next_line.isMQ){
                    next_line.MQ.focus()
                    next_line.MQ.moveToLeftEnd()
                  } else {
                    var cursorpos = getCaretPosition(line.span[0])
                    var maxpos=next_line.span.text().length
                    if(maxpos<cursorpos){
                      cursorpos=maxpos
                    }
                    setCaretPosition(current_page.lines[current_line_number+1].span[0],cursorpos)
                  }
                }
              }
            }
          }
          if(e.keyCode==8) {//backspace
            if (current_line_number !== false ) { //this means that a line is selected
              var line = current_page.lines[current_line_number]
              if(line.isMQ){
                //mq is handled within the mathquill library, so we can safley ignore this.
              } else { //is cursor @ beginning?
                if(getCaretPosition(line.span[0])==0){//are we at beginning of text?
                  e.preventDefault()
                  if(current_line_number!=0){//don't want to delete whole page
                    var preceding_line = current_page.lines[current_line_number-1];
                    if (preceding_line.isMQ) {
                      //if the current line is not empty, dont do anytihng. if it is empty, delete it!
                      if(line.span.text().length == 0){
                        current_page.lines.splice(current_line_number,1);//now remove old line
                        line.span.remove();//delete it from doc
                        line.dom.remove();
                        preceding_line.MQ.focus()
                        preceding_line.MQ.moveToRightEnd()
                      }
                    } else {
                      var text = line.span.text();
                      var preceding_line_text = preceding_line.span.text()
                      var new_cursor_pos = preceding_line_text.length;
                      preceding_line.span.text(preceding_line_text+text);//add this lines text to the last line. the extra char is because we don't want to override the deleting action
                      current_page.lines.splice(current_line_number,1);//now remove old line
                      line.span.remove();//delete it from doc
                      line.dom.remove();
                      preceding_line.span.focus()
                      setCaretPosition(preceding_line.span[0],new_cursor_pos)//sets the cursor in the right spot
                    }
                  } else {
                    if(current_page.lines.length==1){
                      if (line.span.text().length==0) {
                        if (pages.indexOf(current_page)!=0) {
                          pages.splice(pages.indexOf(current_page),1)
                          line.span.remove()
                          line.dom.parent().remove()
                          line.dom.remove();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        })
        $("body").on('keypress', function (e) {
          /*
            we use two differetnt types of binding because
            keypress is generally better than the alternative but you
             cant overide backspace with it
          */
          if(loading===true){//this stops typing during loading
            e.preventDefault()
            return;
          }
          if(e.which === 13 && !e.ctrlKey /*enter*/ ){
            e.preventDefault()//potential trouble
            breakLine();//it just chops off the right side of text and adds it to a new line.
          }
          if (e.which == 12){//ctrl + l means mathquillify or demathquillify. this is so long because we have to keep the array ordered
            e.preventDefault()
            mathLineify()
          }
          if(e.which==14){//ctrl + n creates a new page
            new_page();
          }
        });
      })();//END OF KEYBINDNINGS FUNCTOIN.
      var current_line_number=false//this global variable is either false if no line is selected or a number if one is
      var current_page=false//same here
      var pages = []; //global var
      var make_editable =(dom)=>{//this just helps jquery know when somehting is clicked by autofocusing it.
        dom.bind('click', function() {
          $(this).focus()
        })
        dom.attr("contentEditable",true)
      }
      function Formatting(){
        dom = arguments[0]//we must bind the formatting to an element
        this.dom        = dom;
        this.bold       = {
          status:false,
          dom:dom,
          change:function () {
            if (!this.status) {
              this.dom.css("font-weight","Bold")
              this.status=true;
            } else {
              this.dom.css("font-weight","")
              this.status=false;
            }
          }
        }
        this.italics    = {
          status:false,
          dom:dom,
          change:function () {
            if (!this.status) {
              this.dom.css("font-style","italic")
              this.status=true;
            } else {
              this.dom.css("font-style","")
              this.status=false;
            }
          }
        }
        this.underline  = {
          /*
            Yes, this code is not in use right now, but you can manually make an
            underlined line using either the console or manually opening the json
            file with something like notepad.
          */
          status:false,
          change:function () {
            //TBD.
          },
          dom:null,
        }
        this.highlight  = {
          /*
            Yes, this code is not in use right now, but you can manually make a
            highlited line using either the console or manually opening the json
            file with something like notepad.
            The reason I havent implemented it is because ctrl + h currently hides things.
          */
          status:0,
          dom:dom.find("span"),
          names:[
            "none",
            "red",
            "orange",
            "yellow",
            "green",
            "cyan",
            "blue",
          ],
          values:[
            "#FFFFFF",
            "#FF0000",
            "#FF8000",
            "#FFFF00",
            "#00FF00",
            "#00FFFF",
            "#0000FF",
          ],
          change:function(value){
            if(typeof value == "string"){
              value = this.names.indexOf(value);
            }
            this.status=value
            this.dom.css("background-color",this.values[value])
          }
        }
        this.clear=()=>{//resets formatting
          this.bold.status = true;
          this.bold.change();//sets it to the opposite, then changes it
          this.highlight.change(0)
          this.italics.status = true;
          this.italics.change();
          this.underline.status = true;
          this.underline.change();
        }
        this.dump=()=>({//dumps an object containing color data
          bold:this.bold.status,
          highlight:this.highlight.status,
          underline:this.underline.status,
          italics:this.italics.status
        })
        if(arguments.length>1){//arguments[1] is a dump
          if (typeof arguments[1]!==undefined) {
            var params=arguments[1];
            this.bold.status = !params.bold;
            this.bold.change();//sets it to the opposite, then changes it
            this.highlight.change(params.highlight)
            this.italics.status = !params.italics;
            this.italics.change();
            // this.underline.status = !params.underline;
            // this.underline.change();
          }
        }
      }
      function InjectLineAfter(line_x_dom){
        /*
         *  this is actually an object constructer. its complicated-- sometimes
         *  we need to add a line after a line and other times we don't have any
         *  line to add it to. this makes it difficult to make just one constructer
         *  because we sometimes need to inject after an html thing, and other times before..
         */
        var tempid = Math.floor(Math.random()*Math.pow(2,16))
        /*
         *  ok yes techincally you could have this run simletaneously and get
         *  two similar random numberss and have all hell break loose, but this is
         *  sufficent
         */
        line_x_dom.after('<div align="left" class="id'+tempid+' single-line"></div>')
        this.dom = $(".id"+tempid);
        this.dom.removeClass("id"+tempid)
        this.dom.addClass("line")
        this.dom.append("<span class='monospace editable id"+tempid+"'></span>")
        this.span=$(".id"+tempid);
        this.span.removeClass("id"+tempid)
        this.format=new Formatting(this.dom);
        this.isMQ=false;
        make_editable(this.span)
      }
      function Line(dom){//todo: separate span and div
        var tempid = Math.floor(Math.random()*Math.pow(2,16))//this is just a saftey feature.
        dom.append('<div align="left" class="id'+tempid+' single-line"></div>')//the container for the line
        this.dom = $(".id"+tempid);//the div
        this.dom.removeClass("id"+tempid)//remove id
        this.dom.append("<span class='monospace editable id"+tempid+"'></span>")
        this.dom.addClass("line")
        this.span=$(".id"+tempid);
        this.span.removeClass("id"+tempid)
        this.isMQ=false;
        this.format=new Formatting(this.dom);
        make_editable(this.span)//this sets up some stuff so we always know the current line
      }
      function Page(){
        var tempid = Math.floor(Math.random()*Math.pow(2,16))
        $("#sheets").append('<div class="id'+tempid+' outerpaper" align="center"><div class="innerpaper" align="left">')
        this.dom=$(".id"+tempid)
        this.dom.removeClass("id"+tempid)
        this.lines=[];
        this.injectline=(type,original_line_number)=>{
          var this_line = new InjectLineAfter(this.lines[original_line_number].dom);
          this.lines.splice(original_line_number+1, 0, this_line);
          if (this_line!=this.lines[original_line_number+1]) {
            throw "error in array splicing!";
          }
          var line_dom = this_line.span;
          this_line.getNumber=()=>(
            this_page.lines.indexOf(this_line)
          )
          var this_page= this;
          this_line.set_active = function() {
            current_line_number=this_line.getNumber()
            if (debug_version) {
              console.log("focus: "+this_line.getNumber());
            }
            current_page=this_page;
          }
          this_line.set_inactive = function() {
            self_line_number=this_line.getNumber()
            if(current_line_number==self_line_number){
              if(debug_version){
                console.log("de focus: "+current_line_number)
              };
              current_line_number=false;
            };
          }
          this_line.bind=function(){
            this.span.bind('focus',this_line.set_active);
            this.span.bind('blur',this_line.set_inactive);
          };this_line.bind()
          return this_line
        }
        this.addline=(type)=>{
          this.lines.push(new Line(this.dom))
          var this_line=this.lines[this.lines.length-1]
          var line_dom = this_line.span;
          this_line.getNumber=()=>(
            this_page.lines.indexOf(this_line)
          )
          var this_page= this;
          this_line.set_active = function() {
            current_line_number=this_line.getNumber()
            if (debug_version) {
              console.log("focus: "+current_line_number)
            }
            current_page=this_page;
          }
          this_line.set_inactive = function() {
            self_line_number=this_line.getNumber()
            if(current_line_number==self_line_number){
              if (debug_version) {
                console.log("de focus: "+current_line_number)
              }
              current_line_number=false;
            };
          }
          this_line.bind=function(){
            this.span.bind('focus',this_line.set_active);
            this.span.bind('blur',this_line.set_inactive);
          };this_line.bind()
        }
        this.addline();
        this.lines[0].span.focus()
      }
      var new_page =()=>{pages.push(new Page())}
      make_editable($(".editable"))
      var save_to_json=()=>{//used to convert entire file to a string. doesnt actually save to filesystem
        var file = {title_text:$("#title-box").text(),pages:[],has_font_for_mq:true}
        if(current_line_number!==false){
          file.focus={line:current_line_number,page:pages.indexOf(current_page)}
        }
        for (var i = 0; i < pages.length; i++) {
          file.pages[i]=[];
          for (var j = 0; j < pages[i].lines.length; j++) {
            if(pages[i].lines[j].isMQ){
              file.pages[i][j]={
                isMQ:true,
                text:pages[i].lines[j].MQ.latex(),
                font_size: pages[i].lines[j].span.css("font-size"),
                div_size:get_div_size(pages[i].lines[j].dom)
              }
            } else {
              file.pages[i][j]={
                isMQ:false,
                text:pages[i].lines[j].span.text(),
                formatting:pages[i].lines[j].format.dump()
              }
            }
          }
        }
        return JSON.stringify(file);
      }
      var help=()=>{
        modal_alert("Just type things.<br>Press <kbd>ctrl + L</kbd> to toggle math mode,<br>Press <kbd>ctrl + N</kbd> for a new page.<br><kbd>Ctrl + B(old)</kbd>, <kbd>Ctrl + I(talics)</kbd> to format a line of text<br>You can rename the title if you click on it.<br>Load means open a file in the current window, and open makes a new window","Help")
      }
      var load_from_json=(instring)=>{
        console.log("loading")
        var summary = "";
        for (var i = 0; i < instring.length; i++) {
          summary+=instring[i];
          if (i>40) {
            break;
          }
        }
        console.log("loading the json starting with:"+summary)
        loading=true
        $(".file-dropdown").removeClass("btn-primary").addClass("btn-info").text("Processing...")
        setTimeout(()=>{//to allow proper rendering
          pages=[];
          $("#sheets").empty()
          file = JSON.parse(instring);
          $("#title-box").text(file.title_text)
          if (file.has_font_for_mq===true) {
            global_override_mq_autofit=true;
          }
          for (var i = 0; i < file.pages.length; i++) {
            new_page();
            current_page=pages[i];
            current_page.lines[0].span.remove()
            current_page.lines[0].dom.remove()
            current_page.lines=[];
            for (var j = 0; j < file.pages[i].length; j++) {
              mqaftoid.pid=undefined
              pages[i].addline();
              current_line_number=j;
              line=pages[i].lines[j];
              if(file.pages[i][j].isMQ){//Broken rihgt now, and it kinda defeats the purpose of the whole program :/
                mathLineify()
                line.MQ.latex(file.pages[i][j].text)
                if (global_override_mq_autofit) {
                  line.dom.removeClass("single-line").addClass(sizes[file.pages[i][j].div_size])
                  line.span.css("font-size",file.pages[i][j].font_size)
                }
              } else {
                line.span.text(file.pages[i][j].text);
                line.format=new Formatting(line.dom,file.pages[i][j].formatting);
              }
            }
          }
          setTimeout(()=>{
            global_override_mq_autofit=false;
            $(".file-dropdown").addClass("btn-success").removeClass("btn-info").text("Loaded!");
            if(file.focus != undefined){
              console.log(file.focus)
              var line = pages[file.focus.page].lines[file.focus.line]
              if(line.isMQ){
                line.MQ.focus()
              } else {
                line.span.focus()
              }
              $('html, body').animate({
                scrollTop: line.dom.offset().top-200
              }, 100);
            }
            loading=false;
            setTimeout(()=>{
              $(".file-dropdown").removeClass("btn-success").addClass("btn-primary").text("File");
            },3000)
          },500)
        },250)
      }
    </script>

    <script>
      require = window.nodeRequire
      var   remote          =  require('electron').remote;
      var   dialog          =  remote.dialog;
      var   fs              =  require('fs'); // require only if you don't already have it
      var   sendMSG=(thing) => {ipc.send('sendMSG', thing)}
      {
        const printPDFBtn   =  $('.print-pdf')
        printPDFBtn.on('click', function (event) {
          ipc.send('print-to-pdf')
        })
        ipc.on('wrote-pdf', function (event, path) {
          $('.print-pdf').text("Success!").addClass("btn-success").removeClass("btn-primary");
          setTimeout(()=>{
            $('.print-pdf').text("Print").removeClass("btn-success").addClass("btn-primary");
          },3000)
        })
        ipc.on('string', (event, message) => {
          alert("foo")
          if (message=="save") {
            saveAs((success)=>{sendMSG("save_"+success);alert(success)});
          }
        });
        ipc.on('load', (event, message) => {
          openPath(message)
        })
      }
      var autosave;
      setTimeout(()=>{
        autosave = setInterval(()=>{
          ipc.send("backup_data",save_to_json())
          ipc.send('backup_path', current_file_path)
        },20000)
      },10000)//this stops overwriting
      var ping = setInterval(()=>{//used to detect crashes that occour when mathqill bugs out. this was made back when those were really common, but it still comes in handy
        ipc.send("ping",true)
      },3000)
      var current_file_path = "";
      function save (){
        fs.writeFile(current_file_path, save_to_json(), function (err) {
          if (err == undefined) {
            $(".file-dropdown").addClass("btn-success").removeClass("btn-primary").text("Saved!")
            setTimeout(()=>{
              $(".file-dropdown").removeClass("btn-success").addClass("btn-primary").text("File")
            },3000)
          } else {
            if (current_file_path=="") {
              saveAs()
            } else {
              var button = $(".file-dropdown").addClass("btn-danger").removeClass("btn-primary").text("Save error!")
              setTimeout(()=>{
                $(".file-dropdown").removeClass("btn-danger").addClass("btn-primary").text("File")
              },3000);
            }
          }
        });
      }
      function saveAs (callback) {
        dialog.showSaveDialog({ filters: [
          { name: 'Notebook', extensions: ['jsonbook'] }
        ]},function (fileName) {
          if (fileName === undefined) return;//user hit cancel
          current_file_path=fileName;
          fs.writeFile(fileName, save_to_json(), function (err) {
            if (err == undefined) {
              ipc.send('backup_path', current_file_path)
              modal_alert("The file has been saved!","Save")
              callback(true);
            } else {
              modal_alert(err.message,"File save error!");
              callback(false);
            }
          });
        });
      }
      function openPath(fileName) {
        console.log("opening "+fileName)
        if (fileName === undefined) return;
        current_file_path=fileName
        fs.readFile(fileName, 'utf-8', function (err, data) {
          load_from_json(data)
          ipc.send('backup_path', current_file_path)
        });
      }

      function openFile (/*mode*/) {//open the dialog box and then actually load it
        dialog.showOpenDialog({ filters: [
          { name: 'Notebook', extensions: ['jsonbook'] }
        ]},function (fileNames) {
          if (fileNames === undefined) return;
          var fileName = fileNames[0];
          var choice = 1;
          if (pages.length != 0){
            choice = dialog.showMessageBox({
              message:"Would you like to open in a new window?",
              buttons:["Yes","No"],
            })
          }
          if (!!choice) {//cast to bool, then not
            openPath(fileName)
          } else {
            ipc.send("open",fileName)
          }
        });
      }

      ipc.send("status","ready")
    </script>
  </body>
</html>
